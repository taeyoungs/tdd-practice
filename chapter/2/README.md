# Chapter 2 - 타락한 객체

**목차**

- [Chapter 2 - 타락한 객체](#chapter-2---타락한-객체)
  - [개요](#개요)
  - [Dollar 부작용?](#dollar-부작용)
  - ["가짜로 구현하기"와 "명백한 구현"](#가짜로-구현하기와-명백한-구현)
  - [돌아보기](#돌아보기)

## 개요

현재 목적은 "작동하는 깔끔한 코드를 얻는 것"이다.

작동하는 깔끔한 코드를 얻는 것은 쉽게 도달할 수 없는 목표다. 수준 높은 프로그래머일에게도 동일하게 해당된다.  
따라서, **나누어서 정복한다(Divide and Conquer)**. 한 번에 도달하기 어려운 목표라면 큰 문제를 작은 문제로 쪼개어 작은 단위의 문제부터 풀어나가는 것이다.

"작동하는 깔끔한 코드를 얻는 것"에서 "**작동하는**"에 해당하는 부분을 먼저 해결한다.

그리고 나서 "**깔끔한 코드**" 부분을 해결하는 것이다.

본격적인 작업에 앞서 할 일 목록을 다시 떠올려보자.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 x 2 = $10~~
- [ ] `amount`를 `private`으로 만들기
- [ ] **`Dollar` 부작용 ?**
- [ ] `Money` 반올림 ?

위 할 일 목록 중에서 이 챕터에서는 `Dollar` 부작용에 대해 알아볼 것이다.

## Dollar 부작용?

Chapter 1에서 테스트를 하나 작성하여 통과하긴 했지만 현재 `Dollar` 클래스에는 부작용이 하나 존재한다.  
바로 `Dollar`에 대해 연산을 수행한 후에 해당 `Dollar`의 값이 바뀌는 점이다.

예를 들어, 다음과 같이 테스트 코드를 작성하고 싶다고 하자.

```javascript
test('어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.', () => {
  const five = new Dollar(5);

  five.times(2);
  expect(five.amount).toBe(10);

  five.times(3);
  expect(five.amount).toBe(15);
});
```

위 테스트는 통과할 수 없다. 왜냐하면 처음 `five` 인스턴스를 만들었을 때의 `five.amount` 값과 `times` 메서드를 처음 호출한 후의 `five.amount` 값이 다르기 때문이다. 즉, 더 이상 5가 아니다.

`times` 메서드가 호출하고 난 뒤 초기화했던 `amount` 필드의 값이 변하는 것이 문제라면 `times` 메서드가 새로운 객체를 반환하게 만드는 것은 어떨까?

새로운 객체를 반환하게 된다면 맨 처음 인스턴스를 생성했을 때 초기화됐던 `amount` 필드의 값은 `times` 메서드를 몇 번 호출하던 그대로일 것이다.  
이렇게 하면 기존에 작성했었단 `Dollar` 클래스의 인터페이스를 수정해야 하긴 하지만 기능 구현에 대한 설계를 매번 완벽하게 할 수 없듯이 인터페이스의 설계도 매번 완벽할 순 없다.

인터페이스 변경에 대한 방향을 정했으므로 이에 맞춰 테스트 코드를 작성한다.

```javascript
test('어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.', () => {
  const five = new Dollar(5);

  let product = five.times(2);
  expect(product.amount).toBe(10);

  product = five.times(3);
  expect(product.amount).toBe(15);
});
```

Chapter 1에서 소개했던 TDD 사이클을 기억한다면 위 테스트 코드를 통해서 막 1번 항목을 완료했다.  
책에서는 자바 코드로 설명을 하고 있기 때문에 컴파일이 되지 않지만 내가 작성하는 예제는 자바스크립트이므로 `times` 메서드는 암묵적으로 `undefined`를 반환하고 이를 참조하는 런타임 환경에서 런타임 에러가 발생한다.

따라서, 테스트가 실패하는 것을 확인했기 때문에 `times` 메서드를 수정한다. 테스트를 통과하기 위해서는 올바른 금액을 갖는 새 `Dollar` 객체를 반환해야 한다.

```javascript
class Dollar {
  amount;

  constructor(amount) {
    this.amount = amount;
  }

  times(multiplier) {
    return new Dollar(this.amount * multiplier);
  }
}

export default Dollar;
```

`times` 메서드에서 새로운 `Dollar` 객체를 반환하도록 만들었다. 이로써 `Dollar`가 가진 부작용을 해결했다.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 x 2 = $10~~
- [ ] `amount`를 `private`으로 만들기
- [x] ~~`Dollar` 부작용 ?~~
- [ ] `Money` 반올림 ?

## "가짜로 구현하기"와 "명백한 구현"

Chapter 1에서는 테스트를 통과하기 위해 가짜 구현으로 시작해서 점차 상세 구현을 만들어갔다. 그에 반해 Chapter 2에서는 떠오르는 구현 내용을 바로 입력한 후 테스트가 통과하는지 지켜봤다.

최대한 빨리 테스트가 통과하는지 통과하지 않는지 확인할 수 있는 방법은 총 3가지다.

- 가짜로 구현하기
- 명백한 구현 사용하기
- 삼각측량

모든 도구는 상황에 맞게 사용하는 것이 가장 중요하다. 모든 일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 계속 더해 나간다.

물론, 명백한 구현을 한다고 테스트를 한번도 돌리지 않는다는 이야기는 절대 아니다.

명백한 구현을 이어나가면서 테스트를 돌려보는 와중 예상치 못한 실패를 만나게 되면 이때 뒤로 한발 물러서서 **가짜로 구현하기** 방법을 사용한다. 이 방법을 통해 천천히 올바른 코드로 리팩토링한다.

> 삼각측량은 Chapter 3에서 소개한다.

## 돌아보기

지금까지 배운 것을 검토해보자.

- 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환했다.
- 스텁 구현으로 바르게 컴파일을 통과하도록 만들었다.
- 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

느낌을 테스트로 변환하는 것은 **TDD**의 일반적 주제다.  
여기서 느낌이란 부작용에 대한 혐오감을 뜻하며 테스트는 하나의 `Dollar` 객체에 곱하기를 두 번 수행하는 것을 말한다.

경험치가 높아질 수록 혹은 TDD를 많이 해본 사람일 수록 이러한 느낌을 잘 캐치하고 테스트로 옮길 수 있을 것이다. 이러한 느낌을 테스트로 잘 옮겨낼 수 있다면 설계를 진행함에 있어서 설계에 살을 붙이기도 쉬어지지 않을까 싶다.

기능을 하나 구현함에 있어서 해당 기능이 가질 수 있는 엣지 케이스들을 인지하고 이에 대한 테스트를 만들어 냄으로써 해당 기능이 상황에 따라 이런 식으로 동작해야 하는지 저런 식으로 동작해야 하는지 논의할 수 있다.
