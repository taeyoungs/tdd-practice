# Chapter 1 - 다중 통화를 지원하는 Money 객체

## 개요

다음과 같은 보고서가 있다고 하자.

| 종목 | 주   | 가격 | 합계  |
| ---- | ---- | ---- | ----- |
| IBM  | 1000 | 25   | 25000 |
| GE   | 400  | 100  | 40000 |
|      |      | 합계 | 65000 |

다중 통화를 지원하는 보고서를 만들려면 통화 단위를 추가해야 한다.

| 종목     | 주   | 가격   | 합계     |
| -------- | ---- | ------ | -------- |
| IBM      | 1000 | 25USD  | 25000USD |
| Novartis | 400  | 100CHF | 40000CHF |
|          |      | 합계   | 65000USD |

또한 환율도 명시해야 한다.

| 기준 | 변환 | 환율 |
| ---- | ---- | ---- |
| CHF  | USD  | 1.5  |

### 할 일 목록

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [ ] $5 x 2 = $10

## 무엇이 필요할까?

새로운 보고서를 생성하려면 어떤 기능들이 있어야 할까?  
즉, 어떤 테스트들이 있어야 이 테스트들이 모두 통과할 경우 제대로 계산되도록 하는 코드가 완성됐다는 걸 확신할 수 있을까?

- 통화가 다른 두 금액을 더해서 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

## 무엇부터 해야할까?

### 1. 할 일 목록 점검하기

코드를 작성하기 전에 앞서 작성했던 할 일 목록을 살펴본다.  
할 일 목록은

- 앞으로 어떤 일을 해야 하는지 알려주고
- 지금 하는 일에 집중할 수 있도록 도와주며
- 언제 일이 다 끝나지는지 알려준다.

완료한 할 일 목록에 대해서는 완료했다는 표시를 해두고 만약 새로운 할 일이 생각났다면 목록에 추가한다.  
이제 다시 할 일 목록을 살펴보자.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [ ] $5 x 2 = $10

상대적으로 쉬워보이는 작은 것부터 시작한다. 따라서, 환율을 반영해야 하는 첫 번째 할 일이 아닌 단순 곱하기인 두 번째 할 일부터 작업한다.

### 2. 무슨 테스트가 필요한지 생각하기

"어떤 객체가 필요한지"를 생각할 것이 아니라 "어떤 테스트가 필요할까?" 부터 생각한다.

1번에서 두 번째 할 일인 곱하기 연산을 선택했다. 이를 테스트하는 코드를 작성한다.  
당연히 사전에 아무런 코드도 작성하지 않았기 때문에 작성하는 테스트 코드는 전부 나사가 빠진 상태다.  
이는 현재로썬 크게 중요하지 않다. 나사가 빠진 부분들을 머릿 속에 기억하거나 적어놓고 실패하는 테스트 케이스를 작성한다.

```javascript
test('어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.', () => {
  Dollar five = new Dollar(5);
  five.times(2);
  expect(five.amount).toBe(five.amount);
});
```

물론, 위에서 작성한 테스트 코드는 컴파일조차 되지 않는다. 이제 위 코드를 실행은 안되더라도 컴파일만은 되게 만들 것이다.  
현재 위 코드에는 4개의 문제가 있다.

- `Dollar` 클래스가 없다.
- 생성자가 없다.
- `times(number)` 메서드가 없다.
- `amount` 필드가 없다.

천천히 하나씩 문제를 해결해 나간다.

1. Dollar 클래스를 정의한다.

   ```javascript
   class Dollar {}
   ```

2. 생성자를 만든다.

   단, 컴파일만 되게 할 것이므로 현재로썬 생성자 안에서 아무것도 하지 않아도 된다.

   ```javascript
   class Dollar {
     constructor(amount) {}
   }
   ```

3. `times` 메서드의 스텁 구현을 진행한다.

   여기서 스텁 구현(stub implementation)이란, 메서드의 서명부와 반환 명령만 적는 식으로 해서, 이 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것을 뜻한다.

   ```javascript
   class Dollar {
     constructor(amount) {}

     times(multiplier) {}
   }
   ```

4. 마지막으로 amount 필드를 추가한다.

   ```javascript
   class Dollar {
     amount;

     constructor(amount) {}

     times(multiplier) {}
   }
   ```

이제 컴파일 에러는 모두 제거됐다. 테스트를 돌려봤을 때 당연히 테스트는 통과하지 못하지만 여기서 중요한건 문제의 목표가 변경됐다는 점이다.  
"다중 통화 구현"에서 "현재 테스트를 통과시킨 후 나머지 테스트도 통과하기"로

다시 돌아와서 당장의 문제를 해결하자. 어떤 죄악을 저질러서라도 테스트를 통과시키는 것이다.

```javascript
class Dollar {
  amount = 10;

  ...
}

export default Dollar;
```

이제 억지로 테스트를 통과하게 만들었으니 테스트는 통과한다.

---

**코드를 작성하면서도 잊지 말아야 한다.**

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

---

### 3. 중복 제거하기

현재까지 코드를 작성해오면서 1 ~ 4번까지의 항목을 모두 수행했다. 이제는 중복을 제거할 차례이다.

현재 테스트 케이스에서의 중복은 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다.  
우리가 해결하고자 하는 할 일은 "어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다."다.

이 말인 즉슨 `어떤 금액 x 어떤 수`가 위에서 초기화 해놓은 10이란 값이란 뜻이고 10은 `2 x 5`나 `5 x 2`로 나눠지게 된다는 뜻이다.

```javascript
class Dollar {
  amount = 5 * 2;

  ...
}
```

5와 2를 한 번에 제거할 순 없기 때문에 초기화 단계에 있는 코드를 `times` 메서드 내부로 한번 옮겨본다.

```javascript
class Dollar {
  amount;

  constructor(amount) {}

  times(multiplier) {
    amount = 5 * 2;
  }
}

export default Dollar;
```

여전히 테스트는 통과하고 있다. 마저 테스트와 코드의 데이터에서 중복을 들어내보자.  
5와 2를 어디서 얻을 수 있는지 생각해보자.

- 5는 생성자의 매개변수를 통해서
- 2는 times 메서드의 매개변수를 통해서

각각 얻을 수 있다. 이를 코드에 적용시켜보자.

```javascript
class Dollar {
  amount;

  constructor(amount) {
    this.amount = amount;
  }

  times(multiplier) {
    this.amount = this.amount * multiplier;
  }
}

export default Dollar;
```

이제 첫 번째 테스트에 완료 표시를 할 수 있게 됐다.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 x 2 = $10~~

까먹지 말고 부작용에 대한 작업도 할 일 목록에 추가해놓자.

- [ ] amount를 private으로 만들기
- [ ] Dollar 부작용 ?
- [ ] Money 반올림 ?

## 돌아보기

지금까지 한 작업을 검토해보자.

- 알고 있는 선에서 작업해야 할 테스트 목록을 만들었다.
- 기능이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
- `jest`에 대한 상세한 사항들은 잠시 무시하기로 했다.
- 스텁 구현을 통해 테스트를 컴파일했다.
- 어떠한 죄악이라도 범하여 테스트를 톰과시켰다.
- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.
- 새로운 할 일들을 한번에 처리하는 대신 할 일 목록에 추가하고 넘어갔다.
