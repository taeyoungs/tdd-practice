# Chapter 3 - 모두를 위한 평등

## 개요

지금의 `Dollar` 객체같이 객체를 객체를 값처럼 쓸 수 있는데 이것을 값 객체 패턴(value object pattern)이라고 한다.

값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것이다.

```javascript
const a = new Dollar(5);

const b = new Dollar(10);
```

완벽하게 이해가 되진 않지만 Chapter 3에서 하고자 하는 건 동일한 클래스로 만들어낸 인스턴스, 즉 값 객체가 동질성을 갖는지 확인하고자 하는 것 같다.

책에서 다음과 같은 말이 나온다.

> 값 객체가 암시하는 것 중 하나는 Chapter 2에서와 같이 모든 연산은 새로운 객체를 반환해야 한다는 것과 값 객체는 `equals` 메서드를 구현해야 한다는 것이다.

~~동일한 클래스로 인스턴스를 생성했을 때 각 인스턴스가 생성자 함수 매개변수로 전달한 값을 인스턴스 변수로 잘 가지고 있는지 ..? 인스턴스가 해당 클래스의 성질을 잘 가지고 있는지 확인하고자 하는게 아닐까 싶다.~~  
자꾸 TDD에서 테스트 코드를 먼저 작성한다는 사실은 잊어버린다. Chapter 3에서 작성하게 되는 테스트 코드는 하나의 클래스로 생성한 두 인스턴스의 동치성을 확인이다. 여기서 두 인스턴스의 동치성 확인은 상수로 딱 떨어지게 만들 수 없다. 그래서 **삼각측량**이라는 방법을 통해 두 인스턴스의 동치성을 일반화하기 위한 테스트 코드를 작성하는 것이다.

Chapter 3에서 확인하고자 하는 것을 알았으니 이에 대한 테스트 코드와 `equals` 메서드를 구현해보자.

> ✋ **주의**
>
> `equals` 메서드를 구현하는 이유는 책에서 사용하는 **JUnit**의 `assertEquals` 메서드가 인자로 전달받은 인스턴스의 `equals` 메서드를 호출해주기 때문이다. 현재 자바스크립트와 jest를 사용하고 있기 때문에 Chapter 4에서 `assertEquals` 대신 `equals` 메서드를 직접 호출하고 이를 통해 반환받은 값을 **jest**의 `toBe` 메서드로 각 인스턴스의 멤버 변수 값을 비교하는 것으로 대체한다.
>
> `expect.any(constructor)`와 같은 **jest** 메서드로 각 인스턴스의 생성자 함수를 비교하는 방법도 가능할 것 같긴 하지만 책에서 `equals` 메서드를 구현하기도 했고 해당 메서드에서 인스턴스의 멤버 변수 값을 비교하여 동치성을 확인하기 때문에 이를 이용하는 방식으로 계속 진행한다.

## 할 일 목록

우선, 할 일 목록에 `equals` 메서드 구현을 적어놓자.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 x 2 = $10~~
- [ ] `amount`를 `private`으로 만들기
- [x] ~~`Dollar` 부작용 ?~~
- [ ] `Money` 반올림 ?
- [ ] **equals()**
- [ ] hashCode()

> hashCode 메서드는 Dollar를 해시 테이블의 키로 쓸 경우를 고려해서 할 일 목록에 추가한다.

## 삼각측량

`equals` 메서드에 대한 테스트 코드를 작성한다.

```javascript
import Dollar from '../js/Dollar';

test('생성자 함수 인자에 동일한 값을 전달한 Dollar 인스턴스는 같아야 한다.', () => {
  expect(new Dollar(5).equals(new Dollar(5))).toBe(true);
});
```

`equals` 메서드를 구현하기 전이므로 테스트는 당연히 통과하지 못한다.

Chapter 3에서는 위 테스트를 해결하기 위해 **삼각측량**이라는 방법을 사용한다. Chapter 2에서 소개했던 테스트를 통과하게 만들기 위한 방법 중 3번째에 해당한다.

삼각측량을 이용하려면 예제가 두 개 이상 있어야만 코드를 일반화할 수 있다.  
따라서, 위 테스트 코드에 두 번째 예제(`$5 != $6`)를 작성한다.

```javascript
import Dollar from '../js/Dollar';

test('생성자 함수 인자에 동일한 값을 전달한 Dollar 인스턴스는 같아야 한다.', () => {
  expect(new Dollar(5).equals(new Dollar(5))).toBe(true);
  expect(new Dollar(5).equals(new Dollar(6))).toBe(false);
});
```

이제 테스트를 통과시키기 위해 `equals` 메서드를 구현한다.

> 책에서는 "동치성을 일반화한다"라고 표현한다.

```javascript
class Dollar {
  amount;

  constructor(amount) {
    this.amount = amount;
  }

  // ...

  equals(instance) {
    return this.amount === instance.amount;
  }
}

export default Dollar;
```

## 언제 사용해야 할까?

삼각측량은 확실히 Chapter 2에서 소개했던 방법 중 가장 특이한 면이 있다. 수학에서 증명을 하는 것과 비슷하다고 해야할까 ..?

그러면 만약 "가짜로 구현하기" 또는 "명백한 구현" 방법을 사용해도 될 것 같은 경우엔 어떡해야 할까? 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보임에도 불구하고 삼각측량을 써야하는 걸까?

그렇진 않은 것이 저자조차 정말 리팩토링을 어떻게 해야할 지 감이 오지 않는 경우에만 사용한다고 한다.  
말 그대로 **리팩토링 방법이 보이지 않을 때 생각의 전환을 위해서** 사용한다는 말이다.

## 또 다른 문제들

`equals` 메서드를 구현하고 테스트를 통과하게 만들었지만 이는 동질성 체크를 일시적으로 해결했을 뿐이다.  
만약 `equals` 메서드의 매개변수에 `null`이나 또 다른 객체가 들어온다면?

Chapter 3에서 다루고자 했던 것은 삼각측량이므로 이러한 문제들을 할 일 목록에만 추가해놓고 넘어가자.

- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 x 2 = $10~~
- [ ] `amount`를 `private`으로 만들기
- [x] ~~`Dollar` 부작용 ?~~
- [ ] `Money` 반올림 ?
- [x] ~~equals()~~
- [ ] hashCode()
- [ ] Equal null
- [ ] Equal object

## 검토

- 디자인 패턴이 하나의 또 다른 기능을 암시한다는 것을 알아챘다.
- 해당 기능을 테스트했다.
- 해당 기능을 간단히 구현했다.
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
- 두 경우를 모두 수용할 수 있도록 리팩토링을 조금 했다.
